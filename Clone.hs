module Clone where

import qualified Data.Set as S
import qualified Data.Map.Strict as M
import Control.Monad.State.Lazy
import Semantics
import NMatrix
import Formula
import Connective

-- | A universal algebraic Clone
newtype Clone a = Clone {
    functions :: S.Set (TruthTable a)
}

type CloneGenerationState a = (Clone a, S.Set Formula)

-- | Given base sets of function over {0,1} A and B, 
-- informs if the connectives in B are in the clone
-- generated by A.
isInClone :: NMatrix Int -> NMatrix Int -> Bool
isInClone baseA baseB = evalState (isInClone_ baseB) startState
    where 
        startState = (Clone tts, fmlas)
        tts = (S.fromList . M.elems . interpretation) baseA
        fmlas = S.map formulaFromConnective (M.keysSet $ interpretation baseA)

-- | Given a base set as initial state A and B another base set of functions over {0,1}, determine
-- if B is in the clone generated by A.
isInClone_ :: NMatrix Int -> State (CloneGenerationState Int) Bool
isInClone_ baseB = 
    do
        (fs, fmlas) <- get
        k <- (pure . biggerArityInterpretation . interpretation) baseB
        -- here goes the magic
        return True

biggerArityInterpretation :: Interpretation a -> Int
biggerArityInterpretation int 
    | M.null int = 0
    | otherwise  = if m < n then n else m
    where
        (x, xs) = M.splitAt 1 int
        n = (length . head . M.elems) x
        m = biggerArityInterpretation xs
